/*
 * Copyright (c) Kuba Szczodrzy≈Ñski 2022-10-3.
 */

package io.github.cloudcutter.ui.exploit

import android.animation.ObjectAnimator
import android.annotation.SuppressLint
import android.os.Build
import android.os.Bundle
import android.util.Log
import android.view.View
import android.view.animation.LinearInterpolator
import androidx.core.view.isVisible
import androidx.fragment.app.viewModels
import androidx.lifecycle.Observer
import androidx.lifecycle.asLiveData
import androidx.lifecycle.lifecycleScope
import androidx.navigation.fragment.navArgs
import androidx.recyclerview.widget.LinearLayoutManager
import com.google.android.material.divider.MaterialDividerItemDecoration
import com.mikepenz.iconics.IconicsDrawable
import com.mikepenz.iconics.utils.colorRes
import com.mikepenz.iconics.utils.sizeDp
import dagger.hilt.android.AndroidEntryPoint
import io.github.cloudcutter.R
import io.github.cloudcutter.data.model.ProfileLightleak
import io.github.cloudcutter.databinding.ExploitFragmentBinding
import io.github.cloudcutter.ext.launchWithErrorCard
import io.github.cloudcutter.ext.toEvent
import io.github.cloudcutter.ext.wifiConnect
import io.github.cloudcutter.ext.wifiScan
import io.github.cloudcutter.ui.base.BaseFragment
import io.github.cloudcutter.ui.base.NetworkAwareFragment
import io.github.cloudcutter.ui.dialogs.LightleakStateDialog
import io.github.cloudcutter.ui.dialogs.StorageDirectoryDialog
import io.github.cloudcutter.work.exploit.event.Event
import io.github.cloudcutter.work.exploit.event.MessageEvent
import io.github.cloudcutter.work.exploit.event.MessageRemoveEvent
import io.github.cloudcutter.work.exploit.event.WiFiConnectRequest
import io.github.cloudcutter.work.exploit.event.WiFiConnectResponse
import io.github.cloudcutter.work.exploit.event.WiFiScanRequest
import io.github.cloudcutter.work.exploit.event.WorkStateEvent
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.cancel
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.receiveAsFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.net.Inet4Address

@AndroidEntryPoint
class ExploitFragment : BaseFragment<ExploitFragmentBinding>({ inflater, parent ->
	ExploitFragmentBinding.inflate(inflater, parent, false)
}), Observer<Event>, CoroutineScope, NetworkAwareFragment {
	companion object {
		private const val TAG = "WorkFragment"
	}

	override val coroutineContext = Job() + Dispatchers.Main
	override val vm: ExploitViewModel by viewModels()
	override var networkAwareCallbacks: MutableList<Any?>? = null

	private val args: ExploitFragmentArgs by navArgs()
	private var defaultIcon: IconicsDrawable? = null
	private var anim: ObjectAnimator? = null

	@SuppressLint("InlinedApi")
	override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
		super.onViewCreated(view, savedInstanceState)

		requirePermissions(
			android.Manifest.permission.ACCESS_COARSE_LOCATION,
			android.Manifest.permission.ACCESS_FINE_LOCATION,
			android.Manifest.permission.ACCESS_NETWORK_STATE,
			android.Manifest.permission.ACCESS_WIFI_STATE,
			android.Manifest.permission.CHANGE_WIFI_STATE,
			android.Manifest.permission.NEARBY_WIFI_DEVICES
				.takeIf { Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU },
		)
	}

	override suspend fun onPermissionsGranted() {
		if (!isAdded) return

		val adapter = ExploitStateAdapter(vm.stateList)

		b.stateList.addItemDecoration(MaterialDividerItemDecoration(
			requireContext(),
			MaterialDividerItemDecoration.VERTICAL,
		).also { it.isLastItemDecorated = false })
		b.stateList.layoutManager = LinearLayoutManager(context)
		b.stateList.adapter = adapter

		vm.storageDir = StorageDirectoryDialog(requireContext()).show() ?: run {
			navigateUp()
			return
		}
		log.open(vm.storageDir)
		vm.log.open(vm.storageDir)

		launchWithErrorCard(b.messageCard) {
			val profile = withContext(Dispatchers.IO) {
				vm.prepare(args.profileSlug)
			}
			b.profileInfo.profile = profile
			val actionId = when (profile) {
				is ProfileLightleak -> LightleakStateDialog(requireContext()).show()
				else -> null
			}
			if (actionId == null) {
				navigateUp()
				return@launchWithErrorCard
			}
			vm.run(actionId)
		}

		vm.event.observe(viewLifecycleOwner, this)
		vm.stateAddedIndex.receiveAsFlow().asLiveData().observe(viewLifecycleOwner) {
			log("State+:", vm.stateList[it].getAsString(requireContext()))
			adapter.notifyItemInserted(it)
			b.stateList.smoothScrollToPosition(it)
			runProgressBar(it)
		}
		vm.stateChangedIndex.receiveAsFlow().asLiveData().observe(viewLifecycleOwner) {
			log("State%:", vm.stateList[it].getAsString(requireContext()))
			adapter.notifyItemChanged(it)
			runProgressBar(it)
		}
	}

	private fun runProgressBar(itemIndex: Int) {
		anim?.cancel()
		val state = vm.stateList[itemIndex]
		val action = state.action
		Log.d(TAG, "State changed progress=${state.progress} error=${state.error} $action")
		if (!state.progress) {
			b.messageCard.messageProgress.progress = 0
			return
		}
		val timeout = action.timeout ?: return
		anim = ObjectAnimator.ofInt(
			b.messageCard.messageProgress,
			"progress",
			timeout.toInt() / 10,
			0,
		)
		anim?.duration = timeout
		anim?.interpolator = LinearInterpolator()
		anim?.setAutoCancel(true)
		anim?.start()
	}

	override fun onChanged(value: Event) {
		launch {
			Log.d(TAG, "Event: $value")
			try {
				handleEvent(value)
			} catch (e: Exception) {
				lifecycleScope.cancel()
			}
		}
	}

	private suspend fun handleEvent(event: Event) {
		when (event) {
			is MessageEvent -> with(b.messageCard) {
				messageCard.isVisible = true
				if (defaultIcon == null) defaultIcon = messageIcon.icon
				messageTitle.setText(event.type.title)
				messageText.text = event.text.format(context ?: return)
				messageIcon.icon = IconicsDrawable(context ?: return, event.type.icon).apply {
					sizeDp = 32
					colorRes = event.type.color
				}
			}
			is MessageRemoveEvent -> with(b.messageCard) {
				messageCard.isVisible = false
				messageTitle.setText(R.string.message_title_running)
				messageText.setText(R.string.message_running)
				messageIcon.icon = defaultIcon
			}
			is WorkStateEvent -> {
				val text = event.text.format(context ?: return)
				log("Device new state: $text")
				b.stateText.text = text
			}
			is WiFiConnectRequest -> {
				var error: String?
				while (true) {
					log("Wi-Fi connection attempt: ${event.ssid} / ${event.password}")
					error = context?.wifiConnect(event.ssid, event.password)
					if (error == null) break
				}
				vm.event.postValue(WiFiConnectResponse())
			}
			is WiFiScanRequest -> {
				log("Wi-Fi scan performed")
				val results = context?.wifiScan() ?: return
				log("Wi-Fi scan results:", results.map { it.SSID })
				delay(200)
				vm.event.postValue(results.toEvent())
			}
		}
	}

	override fun onAddressesChanged(local: Inet4Address?, gateway: Inet4Address?) {
		vm.localAddress = local
		vm.gatewayAddress = gateway
	}

	override fun onAddressesTextChanged(local: String?, gateway: String?) {
		b.wifiState.localAddress = local
		b.wifiState.gatewayAddress = gateway
		log("IP addresses changed: $local / $gateway")
	}

	override fun onConnectedSsidChanged(ssid: String?, rssi: Int?) {
		b.wifiState.wifiSsid = ssid
		b.wifiState.wifiRssi = rssi ?: 0
		log("Wi-Fi SSID changed: $ssid")
	}

	override fun onStart() {
		super<BaseFragment>.onStart()
		super<NetworkAwareFragment>.onStart()
	}

	override fun onStop() {
		super<BaseFragment>.onStop()
		super<NetworkAwareFragment>.onStop()
	}
}
